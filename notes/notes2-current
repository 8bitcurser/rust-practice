---- Slice Type

Like python lets you reference a series of contiguous elements in a collection
rather than the whole thing.


let s = String::from("hello world");
let hello = &s[..5];
let world = &s[6..];

let s = "Hello" is a stirng literal, s will be of the type &s and is immutable
given that &s are immutable references.

if we want functions to be able to take stirng literals and normal strings
the type of the function paramenter should be &str as it supports both of them
and not only strings like &String


we can slice other things such as arrays like the following

let a = [1, 2, 3, 4, 5];
let slice = &a[..3];


---- Structs

similar to tuples can have different types but do not need indexing to acquire
each element.

struct User {
        username: String,
        email: String,
        sign_in_count: u64,
        active: bool
}


let user = User {
        email: String::from("tom@test.com"), // we dont use &str cause when the
                                            // struct goes out of scope we want
                                            // the data to go out as well.
        username: String::from("tomowl"),
        active: true,
        sign_in_count: 1
};

user1.email = String::from("another@email.com");

All the struct is mutable, the expression can be returned in a function

fn build_user(email: String, username: String) -> User {
        User{
                email: email, // this is annoying to repeat
                username: username, // as well as here
                active: true,
                sign_in_count: 1
        }
}


this is a better more "simple implementantion" if the parameter is named as the
field. This is called ~~ filled init shorthand syntax ~~

fn build_user(email: String, username: String) -> User {
        User {
                email,
                username,
                active: true,
                sign_in_count: 1
        }
}


making a struct instance out of another struct instance

let user2 = User {
        email: String::from("user2@email.com");
        username: String:from("username2");
        ..user1
}

This copies all the remaining data from user1 that hasn't been explictly
modified.

We could go full explicit doing active: user1.active and 
sign_in_count: user1.sign_in_count but... kinda boring isn't it?


--- tuple structs

Like tuples but... different.

useful when you need a special type of tuple that is different from all the
others.

Awesome for something like a vector.

struct Vector(i32, i32, i32);
struct Color(u32, u32, u32);

let origin = Vetor(0, 1, 2);
let red = (255, 0, 0);


Color and Vector are different types, even if they are tuple structs.


--- unit-like structs.

Structs that have no fields, kinda like the base Exception class

In rust they are similar to (). Useful to implement a trait that doesn't need
to store any data.


