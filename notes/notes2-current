---- Slice Type

Like python lets you reference a series of contiguous elements in a collection
rather than the whole thing.


let s = String::from("hello world");
let hello = &s[..5];
let world = &s[6..];

let s = "Hello" is a stirng literal, s will be of the type &s and is immutable
given that &s are immutable references.

if we want functions to be able to take stirng literals and normal strings
the type of the function paramenter should be &str as it supports both of them
and not only strings like &String


we can slice other things such as arrays like the following

let a = [1, 2, 3, 4, 5];
let slice = &a[..3];


---- Structs

similar to tuples can have different types but do not need indexing to acquire
each element.

struct User {
        username: String,
        email: String,
        sign_in_count: u64,
        active: bool
}


let user = User {
        email: String::from("tom@test.com"), // we dont use &str cause when the
                                            // struct goes out of scope we want
                                            // the data to go out as well.
        username: String::from("tomowl"),
        active: true,
        sign_in_count: 1
};

user1.email = String::from("another@email.com");

All the struct is mutable, the expression can be returned in a function

fn build_user(email: String, username: String) -> User {
        User{
                email: email, // this is annoying to repeat
                username: username, // as well as here
                active: true,
                sign_in_count: 1
        }
}


this is a better more "simple implementantion" if the parameter is named as the
field. This is called ~~ filled init shorthand syntax ~~

fn build_user(email: String, username: String) -> User {
        User {
                email,
                username,
                active: true,
                sign_in_count: 1
        }
}


making a struct instance out of another struct instance

let user2 = User {
        email: String::from("user2@email.com");
        username: String:from("username2");
        ..user1
}

This copies all the remaining data from user1 that hasn't been explictly
modified.

We could go full explicit doing active: user1.active and 
sign_in_count: user1.sign_in_count but... kinda boring isn't it?


--- tuple structs

Like tuples but... different.

useful when you need a special type of tuple that is different from all the
others.

Awesome for something like a vector.

struct Vector(i32, i32, i32);
struct Color(u32, u32, u32);

let origin = Vetor(0, 1, 2);
let red = (255, 0, 0);


Color and Vector are different types, even if they are tuple structs.


---- unit-like structs.

Structs that have no fields, kinda like the base Exception class

In rust they are similar to (). Useful to implement a trait that doesn't need
to store any data.

---- Enums


are similar to algebraic data types.

[If you can -enumerate- all posible values then its probably an enum]

eg for ip addresses only v4 and v6

enum IpAddrKind{
        V4,
        V6
}



let ipv4 = IpAddrKind::V4;


V4 and V6 are the same type so we can write a function with the following
signature

fn route(ip_kind: IpAddrKind){
        //stuff
}

and we may pass either v4 or v6

route(IpAddrKind::V6);


using it with a struct that represents an ip address

struct IpAddr {
        kind: IpAddrKind,
        address: String,
}


let home_addr = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1")
};


This could be even more concise and more elegant

enum IpAddr {
        V4(String),
        V6(String)
}

let home_addr = IpAddr::V4(String::from("127.0.0.1"));

// less code is better code

each enum variant can have a â‰  type and amounts of associated data.

for example and IPV4 is conformed of 4 digits that go from 0 up to 255

while IPV6 can have HEX values represented by strings so a better more

precise implementation of the previously stated would be.


enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String)
}

and instanciated like this

let home_addr = IpAddr::V4(127, 0, 0, 1);


the standar library has an implementation for this but instead it makes the 
type of V4 and V6 to structures called Ipv4Addr and Ipv6Addr respectively.


Enum types can be whatever even other enums.


Enums lets us create custom data types with a mix of many different things
like:

enum Message {
        Quit, // unit struct
        Move {x: i32, y: i32}, // anonymous struct
        Write(String),
        ChangeColor(u8, u8, u8), //tuple representing RGB
}


we can also implement methods for our enums with the impl block like
the struct.

---- The option enum


[For most languages null means that there is no value at a place, 
like python that None is something, Rust doesnt have this as it can
lead to mistakes]

Null is needed in most scenarios thats why rust as it doesnt implement
a null pointer it has the Option enum which tells you whether something is
present or not.

== Read on Option<T> implmentation and usage ==

<T> means any Type
enum Option<T> {
        Some(T),
        None,
}

let some_num = Some(5);
let some_string = Some("A string");

// Rusts compiler doesnt know what type Some will be by looking at None
// so we gotta specify it.
let absent_number: Option<i32> = None;


To be able to use something inside a Some(T) we gotta extract the T first
if not Rust won't be able to use it. This lets you catch a problem that would
be using a null when you actually where expecting a value.


If you want to have something be None you gotta work it, meaning you have
to create the type of that value Option<T> then when you using that value

you gotta explicitly handle that scenario like with match <- super cool.


If you use an Option<T> be ready to handle each and every case.

match and Option<T> are match made in heaven.


--- match control flow operator.











