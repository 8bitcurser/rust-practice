---- Unsafe rust

Allows:

* deference a raw pointer
* call an unsafe function or method
* access or modify a mutable static variable
* implement unsafe traits

using unsafe on a block, still checks for borrows and does all safety checks
the only difference is that enables those 4 things.

A good practice is wrapping unsafe code in a safe block and give it access 
through a safe API.


--- deference a raw pointer

safe rust ensures references are valid always, unsafe rust on the other hand
allows the existance of "raw pointers", they can be mut or inmut and are 
written like

*const T
*mut T

[* doesnt stand for deference it is part of the type name]

in this context immutable means it can be directly assigned after being 
deferenced.


raw pointers are allowed to

> skip borrowing rules by having immutable and 
mutable pointers or mutiple mutable pointers to the same location.

> they may not point to valid memory

> may be null

> they are not automatically cleaned up

we could use them to obtain a greater performance or for interacting with 
things rust usually doesnt apply like OS, languages, hardware, etc.


e.g

let mut num = 5;

let r1 = &num as *cons i32;
let r2 = &num as *mut i32;

// we didnt need to mark as unsafe as raw pointers are allowed in safe code.
// but they can not be deferenced


in this case the reference comes from another one, so the ref is ok and will
work

let address = 0x012345usize;
let r = address as *const i32;

this will explode if we try to do something fishy with it as the address is
invalid

let mut num = 5;

// without raw pointers this wouldn't have compiled as rust does not allow
// mut and immut references to the same data to coexist as they may introduce
// race conditions
let r1 = &num as *cons i32;
let r2 = &mut num as *mut i32;

// we need the unsafe block to deference them
unsafe {
    println!("r1 is {}", *r1);
    println!("r2 is {}", *r2);    
}

this is usually used when interfacing with C or when building safe abstractions


--- calling unsafe function or method

prefixing a function with unsafe indicates that some unsafe magic might be 
going on inside and we read its doc and we are ok with it, but to call them we
need to wrap them in an unsafe block

e.g.

unsafe fn dangerous() {}

unsafe {
    dangerous();
}


--- safe abstraction over unsafe code

its common practice that we may wrap unsafe function inside a safe wrapper,
this means the function may execute an unsafe block within it but the overall
function is safe to use and be called without needing to wrap it again (the
call) inside an unsafe block, this is the case of the split_at_mut which uses
raw pointers to slice a vector in two parts and returns a vector for each 
part, the unsafe block exists inside the method and for the user its safe and
transparent

--- using extern functions to call external code

the extern keyword allows the creation and use of FFI (foreign function
interface) which allows us to define methods that other languages might call,
functions declares with an extern are always unsafe as they do not have and
provide the data safe garantees of rust.

e.g


// the "C" is an ABI (application binary interface) it defines how to call
// the function at assembly level, this is the most common and refers to the 
// C lang
extern "C" {
    fn abs(input: i32) -> i32;
}


fn main(){
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}

--- accesing or modifying a mutable static variable

global variables aka static variables

e.g
// they get a static mem addr, diff to constants which are duplicated when the
// data is used. also constants can be mutated while statics yes, but its 
// unsafe
static HELLO_WORLD: &str = "Hello World";
fn main() {
    println!("name is {}", HELLOW_WORLD);
}


e.g 2

static mut COUNTER: u32 = 0;
fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main(){
    add_to_count(3);
    // either reading and writing happens at the unsafety
    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}



--- implementing unsafe traits.


unsafe traits are those that have at least one of its methods with variants 
that cant be verified


unsafe trait Foo {
    //
}

unsafe impl Foo for i32 {
    // bleah
}

this would be the case if some method from the trait uses raw pointers then
the whole trait should be unsafe.


---- Placeholder Type in Trait defintions with associated Types.

It allows one to define a type inside the trait definition which can be used
in one of the method definition signatures.


e.g
put trait Iterator {
    // place holder type
    type Item;
    // signature using the type.
    fn next(&mut self) -> Option<Self::Item>;
}

this associated types are similar to generics


comparisson examaple:
=======
placeholder type.

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        // ...
    }
}

=======
generics

pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}


the difference between them is that every time we implement the generic version
we have to annotate the types for each implementation as the Generic could be
whatever. This allows the type that implements the trait with generic parameters
to implement it for multiple different types, when using the next method on 
counter we will need to write type annotations to let the compiler know which
implementation are we going to use.


associated types are more specific when it comes to this, we dont need to 
annotate the type cause we already set it at the place holder type, it will
return whatever we define type to be on the implmementation and as we cant
implement the trait multiple times on a type,
 so it will exist only one implementation.

--- default generic type parameters and operator overloading.

generics may have a default type by doing <PlaceHolderType=ConcreteType>

This is used on operator overloading, which is customizing the behaviour of an
operator such as +.

Rust blocks the capability of creating custom operators or overloading 
arbitrary operators. Those one std::ops are overloadable if the corresponding
trait is implemented.

e.g

use std::ops::Add;

#[derivce(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32
}


impl Add for Point {
    type Output = Point;
    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y
        }

    }
}


fn main() {
    assert_eq!(Point: {x: 1, y: 0} + Point {x: 2, y: 3},
               Point {x: 3, y: 3});
}


how Add looks in the standard lib


// default type parameter
// the defult will be self and self is the type in which we are implementing
// the trait
trait Add<RHS=Self> {
    type Output;
    fn add(self, rhs: RHS) -> Self::Output;
}


a case where we specify a special RHS

use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

// setting rhs
impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}


--- syntax for disambiguation: call methods with the same name


two traits might have the a method with the same name, in those cases we need
to tell rust which we want to use if both are implmented at the same type.


trait Pilot {
    fn fly(&self);
}


trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!(This is your captain speaking!");
    }
}


impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}


impl Human {
    fn fly(&self) {
        println!("*Shake arms like a chicken*);
    }
}


fn main() {
    let person = Human;
    // this will call the fly that was implemented on the type as is the 
    // default behavior to call the ones of the traits we need to be specific
    person.fly();
    Pilot::fly(&person);
    Wizard::fly(&person);
    Human::fly(&person); // would have done the same as line 347
}


-- case with associated fn on traits

associated functions of tratis do not have the self parameters passed on to
them, if two types implement the same trait and this trait has an associated 
function and both types implement the function rust can not know which one of
them call the function thats why we need to use fully qualified syntax.

e.g


trait Animal {
    // associated function
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}


fn main() {
    // this will print Spot which is not gooda
    // we cant do Anima::baby_name as it is an asscoiated function and not a
    // method so it doesnt have "self"
    println!("A baby dog is called a {}", Dog::baby_name());
    // this removes the ambiguity and tells rust it wants to use the baby name
    // method implementation from the animal trait the dog type.
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}


fully_qualified syntax = <Type as Trait>::function(receiver_if_method, args..)

receiver is in the case this was not an associated function


-- Super trait, require a functionality of another trait to implement ones
   trait


use std::fmt;

// my trait requires the implementation of the display trait in order to work
// and the method_x function to run.

trait MyTrait: fmt::Display {
    fn method_x(&self) {
        // ...
    }
}

struct Bleh {}

// this will explode as Display hasn't been implemented for Bleh
// impl MyTrait for Bleh {}
impl fmt::Display for Bleh {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Bleh");
    }
}



// now we can do

impl MyTrait for Bleh {}


-- new type pattern to implement ext traits on ext types

previously we saw that either the type or the trait must be local to the crate
in order to use something external, the new type pattern is a workaround to
this, this pattern creates a new type within a tuple struct.
This way we wrapp the new type within a local type

the tuple struct has one field and is a thin wrapper around the type, and now
we may implement the trait to the wrapper.

this pattern has no runtime overhead, and the wrapper type is elided(ommited)
at compile time


use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
       write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}

the downside is Wrapper is a type and therefor it doesnt have the methods from
the inner type, to have them we have to implement them manually. A workaround
this would be implementing the Deref trait on wrapper as to return the inner
type on the wrapper.


--- Advance types

-- newtype pattern for type safety and abstracion

if we implement two types that wrap a u32, and we make a function that takes
the first type this function will never accept a plain u32 or the second type,
making it safe.


wrapping can also make for a safer api, by wrapping we can pick what we trully
expose while keeping the inner type private with its methods, this pattern
its neat for encapsulation


--- type aliasing

rust allows one to give a type another name.

// we are aliasing i32 to Kilometers
type Kilometers = i32;

when we declare a var with the type kilometers it will be treated the same as 
if it was an i32.

its commonly used to remove lengthy type names such as 

Box<dyn Fn() + Send + 'static>

type Thunk = Box<dyn Fn() + Send + 'static>

let f: Thunk = Box::new(|| println!("Hi"));

also commonly used with Result<T, E>

e.g


use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;
    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}

type Result<T> = Result<T, std::io::Error>;

// this will simplify it this way

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}

Boila less code!


--- the ! type

this is the empty type which has no values, in rust is called the "never type"
fn bar() -> ! {
}
its kinda equivalent to void, functions that return the never type are called
divergent functions

in match expressions we see this when if nothing is matched we may execute 
a panic!, rust sees the ! and knows that that arm wont return anything and the
proper return is the other arm.


--- dynamically sized types


DST or unsized types, are types which we can not know the final size in 
compile time only in runtime, one of this examples is str
