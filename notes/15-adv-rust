---- Unsafe rust

Allows:

* deference a raw pointer
* call an unsafe function or method
* access or modify a mutable static variable
* implement unsafe traits

using unsafe on a block, still checks for borrows and does all safety checks
the only difference is that enables those 4 things.

A good practice is wrapping unsafe code in a safe block and give it access 
through a safe API.


--- deference a raw pointer

safe rust ensures references are valid always, unsafe rust on the other hand
allows the existance of "raw pointers", they can be mut or inmut and are 
written like

*const T
*mut T

[* doesnt stand for deference it is part of the type name]

in this context immutable means it can be directly assigned after being 
deferenced.


raw pointers are allowed to

> skip borrowing rules by having immutable and 
mutable pointers or mutiple mutable pointers to the same location.

> they may not point to valid memory

> may be null

> they are not automatically cleaned up

we could use them to obtain a greater performance or for interacting with 
things rust usually doesnt apply like OS, languages, hardware, etc.


e.g

let mut num = 5;

let r1 = &num as *cons i32;
let r2 = &num as *mut i32;

// we didnt need to mark as unsafe as raw pointers are allowed in safe code.
// but they can not be deferenced


in this case the reference comes from another one, so the ref is ok and will
work

let address = 0x012345usize;
let r = address as *const i32;

this will explode if we try to do something fishy with it as the address is
invalid

let mut num = 5;

// without raw pointers this wouldn't have compiled as rust does not allow
// mut and immut references to the same data to coexist as they may introduce
// race conditions
let r1 = &num as *cons i32;
let r2 = &mut num as *mut i32;

// we need the unsafe block to deference them
unsafe {
    println!("r1 is {}", *r1);
    println!("r2 is {}", *r2);    
}

this is usually used when interfacing with C or when building safe abstractions


--- calling unsafe function or method

prefixing a function with unsafe indicates that some unsafe magic might be 
going on inside and we read its doc and we are ok with it, but to call them we
need to wrap them in an unsafe block

e.g.

unsafe fn dangerous() {}

unsafe {
    dangerous();
}


--- safe abstraction over unsafe code

its common practice that we may wrap unsafe function inside a safe wrapper,
this means the function may execute an unsafe block within it but the overall
function is safe to use and be called without needing to wrap it again (the
call) inside an unsafe block, this is the case of the split_at_mut which uses
raw pointers to slice a vector in two parts and returns a vector for each 
part, the unsafe block exists inside the method and for the user its safe and
transparent

--- using extern functions to call external code

the extern keyword allows the creation and use of FFI (foreign function
interface) which allows us to define methods that other languages might call,
functions declares with an extern are always unsafe as they do not have and
provide the data safe garantees of rust.

e.g


// the "C" is an ABI (application binary interface) it defines how to call
// the function at assembly level, this is the most common and refers to the 
// C lang
extern "C" {
    fn abs(input: i32) -> i32;
}


fn main(){
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}

--- accesing or modifying a mutable static variable

global variables aka static variables

e.g
// they get a static mem addr, diff to constants which are duplicated when the
// data is used. also constants can be mutated while statics yes, but its 
// unsafe
static HELLO_WORLD: &str = "Hello World";
fn main() {
    println!("name is {}", HELLOW_WORLD);
}


e.g 2

static mut COUNTER: u32 = 0;
fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main(){
    add_to_count(3);
    // either reading and writing happens at the unsafety
    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}



--- implementing unsafe traits.


unsafe traits are those that have at least one of its methods with variants 
that cant be verified


unsafe trait Foo {
    //
}

unsafe impl Foo for i32 {
    // bleah
}

this would be the case if some method from the trait uses raw pointers then
the whole trait should be unsafe.
