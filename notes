21/4/20

Rust is a an ahead of time compiled language, this means you can give the 
compiled version to someone and they may run it even without having Rust
installed.


==================== CARGO ====================

[create a project using cargo]

>> cargo new test_project

cargo is the package manager from rust it also can build the code.


TOML (Toms obvious minimal language) is the format used by cargo config files.

Rust packages == Crates

[build project using cargo]

>> cargo build

(run inside the cargo project directory)

 Creates an executable at project_directory/target/debug/test_project
 can run executable as (inside project dir) ./target/debug/test_project

the build triggers also the generation of a file called Cargo.lock,
it just pins the exact dependencies.


[compile and run using cargo]

>> cargo run


[check code but not compile]

>> cargo check


If ready for release you can use 

>> cargo build --release 

This runs a bunch of optimizations, creates exe at 
project_directory/target/release

================================================

~~~~~~~~~~~~~~~~~~~~

- import sintax

use package::something;


- variable declaration

[Variables are inmutable by default in rust]

let mut name_of_varaible = something;

mut stands for mutable, if it wouldn't be placed we cant change the value
of it.


- calling associated functions of Types.

Type::associated_method() associated functions are equivalent to static methods


Mutable references are passed as &mut varirable name rather than &variable_name

- Result type

Rust has many different Result types a generic one and many specifics to each
module, library

Result types are enums, which means it has a fixed set of values that
are called "variants"
These variants are Ok and Err,

 Ok --> stands for successful operation
 Err --> provides info on why this failed.


 - formating prints

 they use the {} as place holders, we pass the variable not the reference
 of it.

 similar to python.


-------------------------------------------------------------------------
22/4/20


Cargo can provide docs on each one of the dependencies (crates) that we have
installed by doing
>> cargo doc --open 

which will display a website with all the docs for each crate

the html files are at project_directory/target/doc/project_name/index.html

============================ RUST =============================

---- match expression

its made of arms, each arm is made of a pattern and the code that should run if
the pattern is fulfilled.

the value passed to match is then compared to each one of its arms.


---- typing

Rust is strongly statically typed but it can infer the type of a variable as
int he case of doing 
let mut test = String::new();

we dont need to tell test is a string but as it has a string assigned it
must be a string.


for ints rust defaults to i32.

Other types are

- i32, u32(unsigned 32), i64.


assigning type to variable:

let test: u32 = 320;


---- shadowing variables

we can reuse varaible names by shadowing, this is commonly used to convert one
type into another

its declaring a new variable with the name using the previous value to
apply a transformation is not the same as making a mutable variable.

this is shadowing

let a = 1;
let a = a + 2;

This is not shadowing

let a;
a = a + 2; <= produces compile error


This is not shadowing

let mut a = 1;
a = a + 2; <= although similar a will remain being mutable while using
shadowing after transformation has been aplied the varaible is inmutable


---- looping

loop {
        // code
} 

generate an infinite loop that must be escaped with break keyword.


---- constants

const TEST: u32 = 100_000;

they wont change the value as we used the const keyword


------------------------------------------------------------------

23/4


---- Data types

                             unsigned    signed (positive, negative)
                                      \ /
                                       |  
                         |- integers ---
                         |- floating - (64, 32)   
                         |- boolean
                         |- char - four bytes in size, unicode scalar value
                scalar - |
             /
data types --
             \
                compound - |- tuples
                           |- arrays


wrapping on ints, if you want to put 256 on a u8 variable (
numbers go from 0 to 255) then instead of storing 256 it stores 1. (it goes all
the way round)

=== signature range of numbers for int ===
unsigned 0 to 2^n - 1
signed - 2^(n-1) to 2^(n-1) - 1


--- tuples

they group different types together, but they have a fixed size and the type
of each element must be specified.

let tup: (i32, f64, u8) = (500, 6.4, 1);

if we do not specify the types rust is going to infer them so 

let tup = (500, 6.4, 1); is also valid

if we wanted to get the 6.4 out of tup we could do pattern matching to
destructure the tuple as follows

let (x, y, z) = tup;

println!("{}", y) would return 6.4 as string

this method is called Destructuring

but we could also acquire each one of the elements individually from the
original tuple by using its index.

println!("{}", tup.1); => 6.4 being printed


--- arrays

Arrays differ from tuples, array elements must all be the same type. Arrays
do have fixed sized like tuples 

let arr = [1, 2, 3, 4];

usually used when we rather have the data stored on the stack rather than the
heap

an array like those in python would be a vector but it is provided by the
standard library

an array with explicit size and element type

let arr: [u8, 5] = [1, 2, 3, 4, 5];

rust also lets us create an array of x elements with the same value as 
follows:

let arr = [3; 5];

this will create an array of 5 elements with the value 3 assigned

arr = [3, 3, 3, 3, 3]


accesing data inside an array is done by indexing

let arr: [u8, 5] = [1, 2, 3, 4, 5];
arr[0];

>> 1


accesing elements out of index produces a runtime error

arr[10]


---- functions


fn keyword
snake case convention

functions can be declared anywhere as long as they are declared


parameters are part of the function signature and their type MUST be declared
it can not be implied.

fn some_func(x: i8, y: u8) {
        println!("{}", -x);
        println!("{}", y);
}



=====================================
Rust is an expression based language
=====================================

---- expressions and statements


> Statements are instructions that do not return a value.
> Expressions evaluate to a resulting value.

varaible assignment -> statement

in rust let x = y = 6 is not possible as the assingment of a varaible does not
produce a return value


== expressions do not include ending semicolons so if I add a ; to the end of
an expession it wont return a value. Functions do not end with semi colons as
they are expressions to rust


function that returns a value


fn five() -> i8 {
        5 // notice the lack of semicolon, with it it wouldnt return
}

this expression will return the value 5, you may return early with the return
keyword but return is synonymous to the last expression of the block inside the
function declaration.


fn multiply_by_two(x: i32) -> i32{
        x * 2
}


numbers by themselves are also expressions.

---- CONTROL FLOW

if, else are expressions.

the code inside each of this expressions is sometimes called "Arms" (like with
match)

control flow expressions can only evaluate bools having said that we can not do

let number = 1;

if number {
        //code

}

this will produce an error. 


combining control flow


if number % 4 == 0 {
        // smthng
} else if number % 3 == 0 {
        // smthn2
}else{
        //smthn 3
}

rust would execute the first arm that matches and wont keep checking

this is possible in rust:

let cond = true;
similar to ternaries , this is possible as control flow is an expression and
returns a value.

let number = if cond {
        5
} else {
        6
};


---- loops take 2

three types, loop, for, while.


break stops a loop but also allows us to return a value after it like

let mut counter = 0;
let result = loop {
        counter += 1;
        if counter == 10 {
                break counter * 2;
        }
}

a while loop requires some sort of conditional checking as in control flow
this is why is not optimal for iteration over defined and static data such as 
arrays a for loop would be better suited


let a = [1, 2, 3, 4, 5]
for element in a.iter() {
        println!("{}", element);
}

way more performant and concise, for loops are just safer.

but what if i would need to iterate over a range of items?

Then the type Range would become handy as it provides a range of consequent
numbers

---- Ownership

this feature allows rust not to have a garbage collector.

== Brief desc:

"Mem is managed through a system of ownership that has a set of rules
which are checked by the compiler at compile time, therefor not affecting
runtime performance at all."


stack -> lifo, the last to be put in is the last to be pulled out.
heap -> the heap is not organized the OS looks some place where it can
locate the size of data we requested and gives us the mem addr location.

The stack has certain constraints, fixed data sizes can be stored at the stack
while unknown sizes must be allocated inside the heap

adding data to the stack is faster than the heap, the OS doesn't need to look 
for a space in memory big enough it just puts it first, same goes with 
retriving data, with the heap you gotta follow the pointer and at the stack you 
just retrieve whatever is first.


When a function is called whatever was passed and whatever its inside is
pushed into the stack, when its done its removed from the stack 
(This is what allows recursivity to exist)


In the case of the heap it is a common practice to keep control what duplicated
data goes to the heap and to swipe the unused data, this is done by the garbage
collector periodically or in our case by the ownership.


== Rules of ownership

1. Each value in rust has a variable that is called its owner
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.


All the previous data types are stored in the stack, but the String data type
is stored in the heap.

String literals are immutable. ~

string literals are let s = "blah blah blah"
String types are those that we used to store user input.

But the trade off is performance string literals are more performant given the
imutability while the string types are not.

String types support mutability by being stored in the heap, mainly as we don't
know how much memory it will take. 


So this memory is requested from the OS at runtime and it must be given back to
the OS.

so with String::from("this is a string"); we are doing the first part the second
one is usually handeled by the garbage collector, like in python.

But rust says FUCK IT, ill allocate this and when its out of scope ill return
it.

Rust, the sneaky industrious bastard, calls a function called drop when the 
string goes out of scope. This kinda simplifies the whole C mambo jampo of 

allocate() and free()





